// Code generated by the Pulumi Terraform Bridge (tfgen) Tool DO NOT EDIT.
// *** WARNING: Do not edit by hand unless you're certain you know what you are doing! ***

package commercetools

import (
	"context"
	"reflect"

	"github.com/pulumi/pulumi-commercetools/sdk/go/commercetools/internal"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

type ProductType struct {
	pulumi.CustomResourceState

	// [Product attribute definition](https://docs.commercetools.com/api/projects/productTypes#attributedefinition)
	Attributes  ProductTypeAttributeArrayOutput `pulumi:"attributes"`
	Description pulumi.StringPtrOutput          `pulumi:"description"`
	// User-specific unique identifier for the product type (max. 256 characters)
	Key     pulumi.StringPtrOutput `pulumi:"key"`
	Name    pulumi.StringOutput    `pulumi:"name"`
	Version pulumi.IntOutput       `pulumi:"version"`
}

// NewProductType registers a new resource with the given unique name, arguments, and options.
func NewProductType(ctx *pulumi.Context,
	name string, args *ProductTypeArgs, opts ...pulumi.ResourceOption) (*ProductType, error) {
	if args == nil {
		args = &ProductTypeArgs{}
	}

	opts = internal.PkgResourceDefaultOpts(opts)
	var resource ProductType
	err := ctx.RegisterResource("commercetools:index/productType:ProductType", name, args, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// GetProductType gets an existing ProductType resource's state with the given name, ID, and optional
// state properties that are used to uniquely qualify the lookup (nil if not required).
func GetProductType(ctx *pulumi.Context,
	name string, id pulumi.IDInput, state *ProductTypeState, opts ...pulumi.ResourceOption) (*ProductType, error) {
	var resource ProductType
	err := ctx.ReadResource("commercetools:index/productType:ProductType", name, id, state, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// Input properties used for looking up and filtering ProductType resources.
type productTypeState struct {
	// [Product attribute definition](https://docs.commercetools.com/api/projects/productTypes#attributedefinition)
	Attributes  []ProductTypeAttribute `pulumi:"attributes"`
	Description *string                `pulumi:"description"`
	// User-specific unique identifier for the product type (max. 256 characters)
	Key     *string `pulumi:"key"`
	Name    *string `pulumi:"name"`
	Version *int    `pulumi:"version"`
}

type ProductTypeState struct {
	// [Product attribute definition](https://docs.commercetools.com/api/projects/productTypes#attributedefinition)
	Attributes  ProductTypeAttributeArrayInput
	Description pulumi.StringPtrInput
	// User-specific unique identifier for the product type (max. 256 characters)
	Key     pulumi.StringPtrInput
	Name    pulumi.StringPtrInput
	Version pulumi.IntPtrInput
}

func (ProductTypeState) ElementType() reflect.Type {
	return reflect.TypeOf((*productTypeState)(nil)).Elem()
}

type productTypeArgs struct {
	// [Product attribute definition](https://docs.commercetools.com/api/projects/productTypes#attributedefinition)
	Attributes  []ProductTypeAttribute `pulumi:"attributes"`
	Description *string                `pulumi:"description"`
	// User-specific unique identifier for the product type (max. 256 characters)
	Key  *string `pulumi:"key"`
	Name *string `pulumi:"name"`
}

// The set of arguments for constructing a ProductType resource.
type ProductTypeArgs struct {
	// [Product attribute definition](https://docs.commercetools.com/api/projects/productTypes#attributedefinition)
	Attributes  ProductTypeAttributeArrayInput
	Description pulumi.StringPtrInput
	// User-specific unique identifier for the product type (max. 256 characters)
	Key  pulumi.StringPtrInput
	Name pulumi.StringPtrInput
}

func (ProductTypeArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*productTypeArgs)(nil)).Elem()
}

type ProductTypeInput interface {
	pulumi.Input

	ToProductTypeOutput() ProductTypeOutput
	ToProductTypeOutputWithContext(ctx context.Context) ProductTypeOutput
}

func (*ProductType) ElementType() reflect.Type {
	return reflect.TypeOf((**ProductType)(nil)).Elem()
}

func (i *ProductType) ToProductTypeOutput() ProductTypeOutput {
	return i.ToProductTypeOutputWithContext(context.Background())
}

func (i *ProductType) ToProductTypeOutputWithContext(ctx context.Context) ProductTypeOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ProductTypeOutput)
}

// ProductTypeArrayInput is an input type that accepts ProductTypeArray and ProductTypeArrayOutput values.
// You can construct a concrete instance of `ProductTypeArrayInput` via:
//
//	ProductTypeArray{ ProductTypeArgs{...} }
type ProductTypeArrayInput interface {
	pulumi.Input

	ToProductTypeArrayOutput() ProductTypeArrayOutput
	ToProductTypeArrayOutputWithContext(context.Context) ProductTypeArrayOutput
}

type ProductTypeArray []ProductTypeInput

func (ProductTypeArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*ProductType)(nil)).Elem()
}

func (i ProductTypeArray) ToProductTypeArrayOutput() ProductTypeArrayOutput {
	return i.ToProductTypeArrayOutputWithContext(context.Background())
}

func (i ProductTypeArray) ToProductTypeArrayOutputWithContext(ctx context.Context) ProductTypeArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ProductTypeArrayOutput)
}

// ProductTypeMapInput is an input type that accepts ProductTypeMap and ProductTypeMapOutput values.
// You can construct a concrete instance of `ProductTypeMapInput` via:
//
//	ProductTypeMap{ "key": ProductTypeArgs{...} }
type ProductTypeMapInput interface {
	pulumi.Input

	ToProductTypeMapOutput() ProductTypeMapOutput
	ToProductTypeMapOutputWithContext(context.Context) ProductTypeMapOutput
}

type ProductTypeMap map[string]ProductTypeInput

func (ProductTypeMap) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*ProductType)(nil)).Elem()
}

func (i ProductTypeMap) ToProductTypeMapOutput() ProductTypeMapOutput {
	return i.ToProductTypeMapOutputWithContext(context.Background())
}

func (i ProductTypeMap) ToProductTypeMapOutputWithContext(ctx context.Context) ProductTypeMapOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ProductTypeMapOutput)
}

type ProductTypeOutput struct{ *pulumi.OutputState }

func (ProductTypeOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ProductType)(nil)).Elem()
}

func (o ProductTypeOutput) ToProductTypeOutput() ProductTypeOutput {
	return o
}

func (o ProductTypeOutput) ToProductTypeOutputWithContext(ctx context.Context) ProductTypeOutput {
	return o
}

// [Product attribute definition](https://docs.commercetools.com/api/projects/productTypes#attributedefinition)
func (o ProductTypeOutput) Attributes() ProductTypeAttributeArrayOutput {
	return o.ApplyT(func(v *ProductType) ProductTypeAttributeArrayOutput { return v.Attributes }).(ProductTypeAttributeArrayOutput)
}

func (o ProductTypeOutput) Description() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ProductType) pulumi.StringPtrOutput { return v.Description }).(pulumi.StringPtrOutput)
}

// User-specific unique identifier for the product type (max. 256 characters)
func (o ProductTypeOutput) Key() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ProductType) pulumi.StringPtrOutput { return v.Key }).(pulumi.StringPtrOutput)
}

func (o ProductTypeOutput) Name() pulumi.StringOutput {
	return o.ApplyT(func(v *ProductType) pulumi.StringOutput { return v.Name }).(pulumi.StringOutput)
}

func (o ProductTypeOutput) Version() pulumi.IntOutput {
	return o.ApplyT(func(v *ProductType) pulumi.IntOutput { return v.Version }).(pulumi.IntOutput)
}

type ProductTypeArrayOutput struct{ *pulumi.OutputState }

func (ProductTypeArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*ProductType)(nil)).Elem()
}

func (o ProductTypeArrayOutput) ToProductTypeArrayOutput() ProductTypeArrayOutput {
	return o
}

func (o ProductTypeArrayOutput) ToProductTypeArrayOutputWithContext(ctx context.Context) ProductTypeArrayOutput {
	return o
}

func (o ProductTypeArrayOutput) Index(i pulumi.IntInput) ProductTypeOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) *ProductType {
		return vs[0].([]*ProductType)[vs[1].(int)]
	}).(ProductTypeOutput)
}

type ProductTypeMapOutput struct{ *pulumi.OutputState }

func (ProductTypeMapOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*ProductType)(nil)).Elem()
}

func (o ProductTypeMapOutput) ToProductTypeMapOutput() ProductTypeMapOutput {
	return o
}

func (o ProductTypeMapOutput) ToProductTypeMapOutputWithContext(ctx context.Context) ProductTypeMapOutput {
	return o
}

func (o ProductTypeMapOutput) MapIndex(k pulumi.StringInput) ProductTypeOutput {
	return pulumi.All(o, k).ApplyT(func(vs []interface{}) *ProductType {
		return vs[0].(map[string]*ProductType)[vs[1].(string)]
	}).(ProductTypeOutput)
}

func init() {
	pulumi.RegisterInputType(reflect.TypeOf((*ProductTypeInput)(nil)).Elem(), &ProductType{})
	pulumi.RegisterInputType(reflect.TypeOf((*ProductTypeArrayInput)(nil)).Elem(), ProductTypeArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*ProductTypeMapInput)(nil)).Elem(), ProductTypeMap{})
	pulumi.RegisterOutputType(ProductTypeOutput{})
	pulumi.RegisterOutputType(ProductTypeArrayOutput{})
	pulumi.RegisterOutputType(ProductTypeMapOutput{})
}
