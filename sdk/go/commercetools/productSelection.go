// Code generated by the Pulumi Terraform Bridge (tfgen) Tool DO NOT EDIT.
// *** WARNING: Do not edit by hand unless you're certain you know what you are doing! ***

package commercetools

import (
	"context"
	"reflect"

	"errors"
	"github.com/pulumi/pulumi-commercetools/sdk/go/commercetools/internal"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

type ProductSelection struct {
	pulumi.CustomResourceState

	// User-defined unique identifier of the ProductSelection.
	Key pulumi.StringPtrOutput `pulumi:"key"`
	// Specifies in which way the Products are assigned to the ProductSelection.Currently, the only way of doing this is to
	// specify each Product individually, either by including or excluding them explicitly.Default: Individual
	Mode pulumi.StringOutput `pulumi:"mode"`
	// Name of the ProductSelection.
	Name pulumi.StringMapOutput `pulumi:"name"`
	// Current version of the ProductSelection.
	Version pulumi.IntOutput `pulumi:"version"`
}

// NewProductSelection registers a new resource with the given unique name, arguments, and options.
func NewProductSelection(ctx *pulumi.Context,
	name string, args *ProductSelectionArgs, opts ...pulumi.ResourceOption) (*ProductSelection, error) {
	if args == nil {
		return nil, errors.New("missing one or more required arguments")
	}

	if args.Name == nil {
		return nil, errors.New("invalid value for required argument 'Name'")
	}
	opts = internal.PkgResourceDefaultOpts(opts)
	var resource ProductSelection
	err := ctx.RegisterResource("commercetools:index/productSelection:ProductSelection", name, args, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// GetProductSelection gets an existing ProductSelection resource's state with the given name, ID, and optional
// state properties that are used to uniquely qualify the lookup (nil if not required).
func GetProductSelection(ctx *pulumi.Context,
	name string, id pulumi.IDInput, state *ProductSelectionState, opts ...pulumi.ResourceOption) (*ProductSelection, error) {
	var resource ProductSelection
	err := ctx.ReadResource("commercetools:index/productSelection:ProductSelection", name, id, state, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// Input properties used for looking up and filtering ProductSelection resources.
type productSelectionState struct {
	// User-defined unique identifier of the ProductSelection.
	Key *string `pulumi:"key"`
	// Specifies in which way the Products are assigned to the ProductSelection.Currently, the only way of doing this is to
	// specify each Product individually, either by including or excluding them explicitly.Default: Individual
	Mode *string `pulumi:"mode"`
	// Name of the ProductSelection.
	Name map[string]string `pulumi:"name"`
	// Current version of the ProductSelection.
	Version *int `pulumi:"version"`
}

type ProductSelectionState struct {
	// User-defined unique identifier of the ProductSelection.
	Key pulumi.StringPtrInput
	// Specifies in which way the Products are assigned to the ProductSelection.Currently, the only way of doing this is to
	// specify each Product individually, either by including or excluding them explicitly.Default: Individual
	Mode pulumi.StringPtrInput
	// Name of the ProductSelection.
	Name pulumi.StringMapInput
	// Current version of the ProductSelection.
	Version pulumi.IntPtrInput
}

func (ProductSelectionState) ElementType() reflect.Type {
	return reflect.TypeOf((*productSelectionState)(nil)).Elem()
}

type productSelectionArgs struct {
	// User-defined unique identifier of the ProductSelection.
	Key *string `pulumi:"key"`
	// Specifies in which way the Products are assigned to the ProductSelection.Currently, the only way of doing this is to
	// specify each Product individually, either by including or excluding them explicitly.Default: Individual
	Mode *string `pulumi:"mode"`
	// Name of the ProductSelection.
	Name map[string]string `pulumi:"name"`
}

// The set of arguments for constructing a ProductSelection resource.
type ProductSelectionArgs struct {
	// User-defined unique identifier of the ProductSelection.
	Key pulumi.StringPtrInput
	// Specifies in which way the Products are assigned to the ProductSelection.Currently, the only way of doing this is to
	// specify each Product individually, either by including or excluding them explicitly.Default: Individual
	Mode pulumi.StringPtrInput
	// Name of the ProductSelection.
	Name pulumi.StringMapInput
}

func (ProductSelectionArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*productSelectionArgs)(nil)).Elem()
}

type ProductSelectionInput interface {
	pulumi.Input

	ToProductSelectionOutput() ProductSelectionOutput
	ToProductSelectionOutputWithContext(ctx context.Context) ProductSelectionOutput
}

func (*ProductSelection) ElementType() reflect.Type {
	return reflect.TypeOf((**ProductSelection)(nil)).Elem()
}

func (i *ProductSelection) ToProductSelectionOutput() ProductSelectionOutput {
	return i.ToProductSelectionOutputWithContext(context.Background())
}

func (i *ProductSelection) ToProductSelectionOutputWithContext(ctx context.Context) ProductSelectionOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ProductSelectionOutput)
}

// ProductSelectionArrayInput is an input type that accepts ProductSelectionArray and ProductSelectionArrayOutput values.
// You can construct a concrete instance of `ProductSelectionArrayInput` via:
//
//	ProductSelectionArray{ ProductSelectionArgs{...} }
type ProductSelectionArrayInput interface {
	pulumi.Input

	ToProductSelectionArrayOutput() ProductSelectionArrayOutput
	ToProductSelectionArrayOutputWithContext(context.Context) ProductSelectionArrayOutput
}

type ProductSelectionArray []ProductSelectionInput

func (ProductSelectionArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*ProductSelection)(nil)).Elem()
}

func (i ProductSelectionArray) ToProductSelectionArrayOutput() ProductSelectionArrayOutput {
	return i.ToProductSelectionArrayOutputWithContext(context.Background())
}

func (i ProductSelectionArray) ToProductSelectionArrayOutputWithContext(ctx context.Context) ProductSelectionArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ProductSelectionArrayOutput)
}

// ProductSelectionMapInput is an input type that accepts ProductSelectionMap and ProductSelectionMapOutput values.
// You can construct a concrete instance of `ProductSelectionMapInput` via:
//
//	ProductSelectionMap{ "key": ProductSelectionArgs{...} }
type ProductSelectionMapInput interface {
	pulumi.Input

	ToProductSelectionMapOutput() ProductSelectionMapOutput
	ToProductSelectionMapOutputWithContext(context.Context) ProductSelectionMapOutput
}

type ProductSelectionMap map[string]ProductSelectionInput

func (ProductSelectionMap) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*ProductSelection)(nil)).Elem()
}

func (i ProductSelectionMap) ToProductSelectionMapOutput() ProductSelectionMapOutput {
	return i.ToProductSelectionMapOutputWithContext(context.Background())
}

func (i ProductSelectionMap) ToProductSelectionMapOutputWithContext(ctx context.Context) ProductSelectionMapOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ProductSelectionMapOutput)
}

type ProductSelectionOutput struct{ *pulumi.OutputState }

func (ProductSelectionOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ProductSelection)(nil)).Elem()
}

func (o ProductSelectionOutput) ToProductSelectionOutput() ProductSelectionOutput {
	return o
}

func (o ProductSelectionOutput) ToProductSelectionOutputWithContext(ctx context.Context) ProductSelectionOutput {
	return o
}

// User-defined unique identifier of the ProductSelection.
func (o ProductSelectionOutput) Key() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ProductSelection) pulumi.StringPtrOutput { return v.Key }).(pulumi.StringPtrOutput)
}

// Specifies in which way the Products are assigned to the ProductSelection.Currently, the only way of doing this is to
// specify each Product individually, either by including or excluding them explicitly.Default: Individual
func (o ProductSelectionOutput) Mode() pulumi.StringOutput {
	return o.ApplyT(func(v *ProductSelection) pulumi.StringOutput { return v.Mode }).(pulumi.StringOutput)
}

// Name of the ProductSelection.
func (o ProductSelectionOutput) Name() pulumi.StringMapOutput {
	return o.ApplyT(func(v *ProductSelection) pulumi.StringMapOutput { return v.Name }).(pulumi.StringMapOutput)
}

// Current version of the ProductSelection.
func (o ProductSelectionOutput) Version() pulumi.IntOutput {
	return o.ApplyT(func(v *ProductSelection) pulumi.IntOutput { return v.Version }).(pulumi.IntOutput)
}

type ProductSelectionArrayOutput struct{ *pulumi.OutputState }

func (ProductSelectionArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*ProductSelection)(nil)).Elem()
}

func (o ProductSelectionArrayOutput) ToProductSelectionArrayOutput() ProductSelectionArrayOutput {
	return o
}

func (o ProductSelectionArrayOutput) ToProductSelectionArrayOutputWithContext(ctx context.Context) ProductSelectionArrayOutput {
	return o
}

func (o ProductSelectionArrayOutput) Index(i pulumi.IntInput) ProductSelectionOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) *ProductSelection {
		return vs[0].([]*ProductSelection)[vs[1].(int)]
	}).(ProductSelectionOutput)
}

type ProductSelectionMapOutput struct{ *pulumi.OutputState }

func (ProductSelectionMapOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*ProductSelection)(nil)).Elem()
}

func (o ProductSelectionMapOutput) ToProductSelectionMapOutput() ProductSelectionMapOutput {
	return o
}

func (o ProductSelectionMapOutput) ToProductSelectionMapOutputWithContext(ctx context.Context) ProductSelectionMapOutput {
	return o
}

func (o ProductSelectionMapOutput) MapIndex(k pulumi.StringInput) ProductSelectionOutput {
	return pulumi.All(o, k).ApplyT(func(vs []interface{}) *ProductSelection {
		return vs[0].(map[string]*ProductSelection)[vs[1].(string)]
	}).(ProductSelectionOutput)
}

func init() {
	pulumi.RegisterInputType(reflect.TypeOf((*ProductSelectionInput)(nil)).Elem(), &ProductSelection{})
	pulumi.RegisterInputType(reflect.TypeOf((*ProductSelectionArrayInput)(nil)).Elem(), ProductSelectionArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*ProductSelectionMapInput)(nil)).Elem(), ProductSelectionMap{})
	pulumi.RegisterOutputType(ProductSelectionOutput{})
	pulumi.RegisterOutputType(ProductSelectionArrayOutput{})
	pulumi.RegisterOutputType(ProductSelectionMapOutput{})
}
